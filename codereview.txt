2.
[문제 요약]
최대 공약수를 구해서 쌍이 같은 애들이 많은걸 구하는 문제
한 쌍의 서로소가 나오는 횟수를 세었을 때, 가장 많이 나오는 횟수는 얼마인가?

[코딩 설명]
gcd 라는 함수는 두개의 수의 최대공약수를 효율적으로 구하는 방법
map을 사용하여 서로소 집합을 카운팅을 하고
최종적으로 가장 많이 카운팅된 서로소 집합이 답이 되게 한다.

[개선할 점]
유클리드 호제법이 왜 효율적인가?
ㄴ 
3.
[문제 요약]
철수는 마당에 있는 나무들 꾸미고 싶습니다.
목표는 나무들을 모두 지그재그로 만들고 싶습니다.
철수는 너무 게을러서 최소한의 개수를 변경해서 지그재그를 만들고 싶어합니다.
최소한의 개수로 지그재그를 만드는 방법을 제안하세요.
나무의 범위는 2 <= 나무 <= 1000 입니다.

[코딩 설명]
우선, 저는 2가지 상황을 답의 전제로 하였습니다.
하나는 나무와 나무 사이를 기준으로 하여, 증가하고 감소하는 답이 있을 수 있고,
감소하고 증가하는 답이 있을 수 있다고 가정했습니다.

그래서 처음 if문은 증감증의 답이고, 다음 if문은 감증감의 답입니다.
두 if문의 결과는 func이라는 함수의 반환값 ret을 비교해서 최소값을 답으로 정했습니다.

그럼 이제 func의 설명으로는, x는 현재 A배열의 인덱스고, num은 A배열의 x번째 값인데, 실제의 A배열의 값이 아닐 수도 있습니다.
즉, 증감형태로 만들기 위해서 이전단계에서 실제보다 증가할수있고 감소할 수 있는 수입니다.
그리고  마지막으로 bool값을 통해 증가해야하는지 감소해야하는지 상태값을 나타내고 있습니다.

처음에는 A배열의 크기를 알아내서 마지막단계인지 아닌지를 확인하고
마지막단계일 때에는 재귀적 호출없이 상황에 맞는 반환값을 return을 한고
추가적으로 진행해야할 단계가 있다면 재귀호출을 통해 답을 구하고 있습니다.

로직을 살펴보면, 증가해야하는 상황에서는 현재값보다 다음값이 더 크거나 같으면
return 0 을, 작게 된다면 return 1 을 반환하게 하였습니다.

현재값과 다음값이 같을 때 카운팅을 안한 이유는 이전단계에서 감소하는 과정에서 비록 실제적인 값은 -1 이 감소하지만
-1 보다 더 감소했다고 가정할 수도 있기에 카운팅을 안했습니다. 문제에서는 얼마나 감소시키지는 중요치가 않기때문이니깐요.
하지만, 제가 여기서 간과했던 점은 이전단계에서 감소하는 과정이 없었다면 오류가 생길 것이라고 생각합니다.

반대의 상황인 감소해야하는 부분도 마찬가지입니다.
또한, 재귀호출이 필요한 부분은 num과 next의 대소에 대한 처리는 위와 같지만, 재귀호출로 파라미터를 달리하여 호출해줍니다.
기울기의 상태와 다음단계에서 쓰일 num을 증감 여부에 따라 +-1 을 해줍니다.

[개선할 점]
앞서 전제로 깔았던 증감의 상태는 고정된채로 문제의 전제로 두게 된다면,
남은 일은 증가나 감소는 무조건적이면, 그럼 얼마나 증가나 감소를 해야하나?가 핵심이라 생각이 들고요
나무의 최대치 or 최소치로 증감을 하면 다음 나무들에게 영향을 최소치로 주어, 문제의 최소값을 찾을 수 있다고 생각합니다.
만약에, 3 - 2 사이에서 증가가 이뤄진다면 3 - 1000 으로 변경하는 것입니다.
이렇게 되면 1000 다음으로 만날수가 1000이랑 같거나, 낮을 것입니다.
우선, 1000이랑 같게된다면 어차피 1000은 감소해야할 운명이기에 감소하는 비용이 추가로 들지는 않습니다.
하지만 1000보다 작은 수가 있다면 저절로 감소하는 형태를 띄기 때문에 감소하는 비용이 추가로 들지 않습니다.
이와 반대로 감소해야하는 상황에서는 최소치 2로 변경하여 증감하는 나무개수를 최소화할 수 있다 생각합니다.
